есть в оперативной памяти stack и heap

stack хранит в себе ссылки на объект, а heap - сам объект

_____________
|            |
|   Stack    |
______________

        |
       \ /
______________
|            |
|   Heap     |
______________


str1 = 'loh'
str2 = 'loh'

в heap хранится один объект 'loh', а в стеке 2 объекта, указывающих на объект в куче

разница изменяемых и неизменяемых в том, что изменяемые используют ту же ячейку в heap,
когда меняют значения, а неизменяемые создают новое и удаляют старое, если на него нет ссылок в стеке

Именно по количеству ссылок в стеке работает garbage collector



None -  16 байт
int - 24
float - 24
строка - 37 байт плюс байт за каждый символ


56 или 48 ()
72 []
96 [4, 'toaster', 230.1] походу по 8 байт на каждую ссылку

словари и кортежи 
280 {} всегда 280
 280 {'a': 213, 'b': 2131}
        72 ('a', 213)   компоненты 62 плюс 10 на саму пару
                38 - a
                24 - 213
        72 ('b', 2131)
                38 - b
                24 - 2131

set 224  жрет очень много памяти : set( range(1,10) ) - 736 байт

проверить кол-во ссылок на объект:

sys.getrefcount(наш объект)

Примеры, когда количество ссылок увеличивается:

оператор присваивания
передача аргументов
вставка нового объекта в лист (увеличивается количество ссылок для объекта)
конструция вида foo = bar (foo начинается ссылаться на тот же объект, что и bar)


плюсы подсчета ссылок: Этот метод практически не уступает по производительности ручному управлению памятью, но при этом позволяет существенно сократить количество присущих ему ошибок. Поддержка кода также упрощается

минусы: В случае с Python этот метод местами мешает ему, это одна из причин почему до сих пор никто не может избавится от GIL. Если убрать подсчет ссылок, то сразу сломается всё API, которое используют библиотеки, написанные с использованием компилиуремых языков (по сути любые компилируемые модули для питона). Из-за подсчета ссылок любое действие над объектом должно быть безопасным, т.к. постоянно меняется счетчик

как создается переменная: выделяется ячейка памяти, туда присваивается значение, на нее указывает ссылка(название переменной)


PyObject:
Все типы объектов являются расширениями этого типа. В обычной «релизной» сборке он содержит только счётчик ссылок на объект и указатель на объект соответствующего типа


блок => пул => арена

В отличие от других популярных языков, Python не освобождает всю память обратно операционной системе как только он удаляет какой либо объект. Вместо этого, он использует дополнительный менеджер памяти, предназначенный для маленьких объектов (размер которых меньше чем 512 байт). Для работы с такими объектами он выделяет большие блоки памяти, в которых в дальнейшем будет хранится множество маленьких объектов.

Как только один из маленьких объект удаляется — память из под него не переходит операционной системе, Python оставляет её для новых объектов с таким же размером. Если в одном из выделенных блоков памяти не осталось объектов, то Python может высвободить его операционной системе. Как правило, высвобождение блоков случается когда скрипт создает множество временных объектов

GC


В отличие от алгоритма подсчета ссылок, циклический GC не работает в режиме реального времени и запускается периодически. Каждый запуск сборщика создаёт микропаузы в работе кода, поэтому CPython (стандартный интерпретатор) использует различные эвристики, для определения частоты запуска сборщика мусора.

Циклический сборщик мусора разделяет все объекты на 3 поколения (генерации). Новые объекты попадают в первое поколение. Если новый объект выживает процесс сборки мусора, то он перемещается в следующее поколение. Чем выше поколение, тем реже оно сканируется на мусор. Так-как новые объекты зачастую имеют очень маленький срок жизни (являются временными), то имеет смысл опрашивать их чаще, чем те, которые уже прошли через несколько этапов сборки мусора.

В каждой генерации есть специальный счетчик и порог срабатывания, при достижении которых срабатывает процесс сборки мусора. Каждый счетчик хранит количество аллокаций минус количество деаллокаций в данной генерации. Как только в Python создается какой либо контейнерный объект, он проверяет эти счетчики. Если условия срабатывают, то начинается процесс сборки мусора.

Если сразу несколько или больше поколений преодолели порог, то выбирается наиболее старшее поколение. Это сделано из-за того, что старые поколения также сканируют все предыдущие. Чтобы сократить число пауз сборки мусора для долгоживущих объектов, самая старшая генерация имеет дополнительный набор условий.

Стандартные пороги срабатывания для поколений установлены на 700, 10 и 10 соответственно, но вы всегда можете их изменить с помощью функций gc.get_threshold и gc.set_threshold.

gc срабатывает когда
первое поколение(Gen 0) занимает - 256 к bytes

второе (gen 1) - 512 kbytes

третье (gen 2 ) - 10 megabytes