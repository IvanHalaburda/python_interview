                                Пример обработки исключений

try:
    x = int(x)
    y = int(y)
 
    res = x/y
except ZeroDivisionError:
    res = "деление на ноль"
print(res)  

                                Немного теории

Более подробно блок try except работает так. Сначала идет выполнение программы внутри блока try. Если все проходит в штатном режиме, то выполнение доходит до блока except и он пропускается, не выполняется. И далее уже вызывается функция print и печатается полученный результат. Если же в процессе выполнения программы блока try возникает какое-либо исключение (любое), то выполнение программы прерывается и управление передается блоку except с соответствующим именем исключения. Если нужное имя в блоке except отсутствует, то исключение переходит на более высокий уровень (в данном случае к среде выполнения Python). И в случае отсутствия обработчика исключение считается необработанным (unhandled exception) и программа завершается аварийно.


Чтобы отловить в блоке try несколько различных исключений, их можно указать в круглых скобках через запятую после ключевого слова except:

except (ZeroDivisionError, ValueError):
    res = "деление на ноль или нечисловое значение"
    
Или, для раздельной обработки, в разных блоках except:

except ZeroDivisionError:
    res = "деление на ноль"
except ValueError:
    res = "одно из введенных значений не число"
Если мы хотим при возникновении ошибок указывать служебное сообщение, записанное в соответствующих исключениях, то это делается так:

except ZeroDivisionError as z:
    res = z
except ValueError as v:
    res = v


Далее, блок try поддерживает необязательный блок else, который выполняется при штатном выполнении кода внутри блока try, то есть, когда не произошло никаких ошибок. Например, его можно записать так:

else:
    print("Исключений не произошло")
Теперь, при запуске программы, вводя корректные числа, мы увидим это сообщение. Если же возникает любое исключение, то этот блок не выполняется.

Другим необязательным блоком является блок finally(выполняется всегда), который, наоборот, выполняется всегда после блока try, вне зависимости произошла ошибка или нет:

finally:
    print("Блок finally выполняется всегда")


                            Виды исключений

Исключения разделяют на синхронные и асинхронные. Синхронные исключения могут возникнуть только в определенных местах программы. Например, если у вас есть код, который открывает файл и считывает из него данные, то исключение типа “ошибка чтения данных” может произойти только в указанном куске кода. Асинхронные исключения могут возникнуть в любой момент работы программы, они, как правило, связаны с какими-либо аппаратными проблемами, либо приходом данных. В качестве примера можно привести сигнал отключения питания.

В языках программирования чаще всего предусматривается специальный механизм обработки исключений. Обработка может быть с возвратом, когда после обработки исключения выполнение программы продолжается с того места, где оно возникло. И обработка без возврата, в этом случае, при возникновении исключения, осуществляется переход в специальный, заранее подготовленный, блок кода.

Различают структурную и неструктурную обработку исключений. Неструктурная обработка предполагает регистрацию функции обработчика для каждого исключения, соответственно данная функция будет вызвана при возникновении конкретного исключения. Для структурной обработки язык программирования должен поддерживать специальные синтаксические конструкции, которые позволяют выделить код, который необходимо контролировать и код, который нужно выполнить при возникновении исключительной ситуации


В Python выделяют два различных вида ошибок: синтаксические ошибки и исключения.(еще есть логические)

                                
                            Иерархия исключений

BaseException
+– SystemExit
+– KeyboardInterrupt
+– GeneratorExit
+– Exception
     +– StopIteration
     +– StopAsyncIteration
     +– ArithmeticError
     |    +– FloatingPointError
     |    +– OverflowError
     |    +– ZeroDivisionError
     +– AssertionError
     +– AttributeError
     +– BufferError
     +– EOFError
     +– ImportError
          +– ModuleNotFoundError

          и много еще ...


                                    Обработка исключений в Python
Обработка исключений нужна для того, чтобы приложение не завершалось аварийно каждый раз, когда возникает исключение. Для этого блок кода, в котором возможно появление исключительной ситуации необходимо поместить во внутрь синтаксической конструкции try…except

Вначале выполняется код, находящийся между операторами try и except.
Если в ходе его выполнения исключения не произошло, то код в блоке except пропускается, а код в блоке try выполняется весь до конца.
Если исключение происходит, то выполнение в рамках блока try прерывается и выполняется код в блоке except. При этом для оператора except можно указать, какие исключения можно обрабатывать в нем. При возникновении исключения, ищется именно тот блок except, который может обработать данное исключение.
Если среди except блоков нет подходящего для обработки исключения, то оно передается наружу из блока try. В случае, если обработчик исключения так и не будет найден, то исключение будет необработанным (unhandled exception) и программа аварийно остановится.


                            Генерация исключений в Python
Для принудительной генерации исключения используется инструкция raise.

Самый простой пример работы с raise может выглядеть так.

try:
   raise Exception("Some exception")
except Exception as e:
   print("Exception exception " + str(e))

                            Пользовательские исключения (User-defined Exceptions) в Python
В Python можно создавать собственные исключения. Такая практика позволяет увеличить гибкость процесса обработки ошибок в рамках той предметной области, для которой написана ваша программа.

Для реализации собственного типа исключения необходимо создать класс, являющийся наследником от одного из классов исключений.

class NegValException(Exception):
   pass

try:
   val = int(input("input positive number: "))
   if val < 0:
       raise NegValException("Neg val: " + str(val))
   print(val + 10)
except NegValException as e:
  print(e)



                                Вложенность конструкции try / except 
Блоки try-except могут быть вложенными для более гибкого управления исключениями. В следующем примере демонстрируется попытка открыть текстовый файл и записать в него некую строку. Для каждой цели используется отдельный блок try.

Также в данном примере используется конструкция else, которая выполняется в случае, если в коде не произошло исключений.
В данном случае — else сработает при успешной операции write. По умолчанию файл открывается на чтение в текстовом режиме. Поэтому при открытии файла будем использовать режим «w». В этом режиме файл открывается на запись. Если файла не было — создается новый, если был — перезаписывается.

print("Program started")
try:
    print("Opening file...")
    f = open("data.txt", "w")
    try:
        print("Writing to file...")
        f.write("Hello World!")
    except Exception:
        print("Something gone wrong!")
    else:
        print("Success!")
except FileNotFoundError:
    print("File not found!")
print("Program finished")

Program started
Opening file...
Writing to file...
Success!
Program finished

                            Assert

По своей сути инструкция Python assert представляет собой средство отладки, которое проверяет условие. Если условие утверждения assert истинно, то ничего не происходит и ваша программа продолжает выполняться как обычно. Но если же вычисление условия дает результат ложно, то вызывается исключение AssertionError с необязательным сообщением об ошибке.


Пример:

def apply_discount(product, discount):
   price = int(product['цена'] * (1.0 — discount))
   assert 0 <= price <= product['цена']
   return price

Дело в том, что инструкция assert предназначена для того, чтобы сообщать разработчикам о неустранимых ошибках в программе. Инструкция assert не предназначена для того, чтобы сигнализировать об ожидаемых ошибочных условиях

1-ое предупреждение по поводу assert

Самое большое предостережение по поводу использования утверждений в Python состоит в том, что утверждения могут быть глобально отключены  переключателями командной строки -O и -OO, а также переменной окружения PYTHONOPTIMIZE в СPython.

Это превращает любую инструкцию assert в нулевую операцию: утверждения assert просто компилируются и вычисляться не будут, это означает, что ни одно из условных выражений не будет выполнено.


2-ое предупреждение по поводу assert

Когда в инструкцию assert в качестве первого аргумента передается кортеж, assert всегда возвращает True и по этой причине выполняется успешно.

Например, это утверждение никогда не будет давать сбой: 

assert(1 == 2, 'Это утверждение должно вызвать сбой')

Эта ситуация связана с тем, что в Python непустые кортежи всегда являются истинными