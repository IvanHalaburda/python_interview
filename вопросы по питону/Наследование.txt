MRO -  method resolution order
Порядок разрешения методов (method resolution order) позволяет Питону выяснить, из какого класса-предка нужно вызывать метод, если он не обнаружен непосредственно в классе-потомке.


Однако, начиная с версии 2.2, появился базовый класс object, от которого рекомендовалось наследовать все пользовательские классы.(в питононе 3 это уже по умолчанию)

Итак, у нас на руках есть сам класс, список всех его предков и связей между ними. Из этих данных нам нужно построить упорядоченный список классов, в которых будет производиться поиск метода слева направо. Такой список называется линеаризацией класса. Для простоты возьмем структуру:

object
   | 
   A
   |
   B


Тогда линеаризацией для класса B будет список [B, A, object]. Т.е. при вызове B().something() метод сначала будет искаться в классе B. Если он там не найден, то поиск продолжится в классе A. Если его нет и там, то поиск завершится в классе object.


   object
   /   \
  A     B
   \   /
     C

Для удовлетворения свойству монотонности в этом случае подойдут две линеаризации: [C, A, B, object] и [C, B, A, object]. Очевидно, что они обе не нарушают монотонности ни в отношении класса A (т.к. object следует за A в обоих случаях), ни в отношении класса B (т.к. object следует за B в обоих случаях). Так какую из них выбрать? В этом случае наиболее интуитивно-понятный способ — посмотреть на определение класса C. Если класс объявлен как C(A, B), то разумно будет взять первую линеаризацию, поскольку в ней B следует за A. Если класс объявлен как C(B, A), то будет лучше взять вторую линеаризацию, в которой A следует за B.  


линеаризацией класса называется список из самого класса и всех его предков (родителей и прородителей) в котором по порядку слева направо будет производиться поиск метода.
порядок разрешения методов (MRO) — это способ, с помощью которого составляется линеаризация класса.
монотонность — это свойство, которое требует соблюдения в линеаризации класса-потомка того же порядка следования классов-прородителей, что и в линеаризации класса-родителя.
порядок локального старшинства — это свойство, которое требует соблюдения в линеаризации класса-потомка того же порядка следования классов-родителей, что и в его объявлении.

   object
   /   \
  A  B  C
   \ | /
     D

 Идем в А -> B > C -> object

Как обращаться к предкам:

super() это не класс-родитель, это объект, позволяющий вызвать следующий по
алгоритму MRO класс.

Название super() вводит в заблуждение - super() вполне может найти метод не в родителе, а в “брате”, если тот следует далее по алгоритму MRO.

class C(B, A):
    def __init__(self):
        # something
        super().__init__() # для версий младше 3.0 нужно использовать super(C, self)


Для поиска методов и полей в дереве родителей (MRO), Python использует C3 алгоритм.
Совсем упрощенно C3 алгоритм MRO можно представить так:

в список добавляются родители объекта

в конец списка добавляет список родителей этих родителей
и так далее
если какой-то класс оказывается в списке дважды, то оставляется только последнее его вхождение.